import math
import pygame
import sys
import pygame.time
from settings import *
import classes.ScoreBar

class MainFish:
    def __init__(self, x, y):
        # T·∫°o t·ª´ ƒëi·ªÉn ch·ª©a c√°c h√¨nh ·∫£nh c·ªßa c√° theo 8 h∆∞·ªõng
        base_size = SCREEN_WIDTH // 25
        self.images = {
            "left_down": pygame.image.load(IMAGE_PATH + "fish_left_down.png"),
            "left_up": pygame.image.load(IMAGE_PATH + "fish_left_up.png"),
            "right": pygame.image.load(IMAGE_PATH + "fish_right.png"),
            "down": pygame.image.load(IMAGE_PATH + "fish_down.png"),
            "left": pygame.image.load(IMAGE_PATH + "fish_left.png"),
            "up": pygame.image.load(IMAGE_PATH + "fish_up.png"),
            "right_down": pygame.image.load(IMAGE_PATH + "fish_right_down.png"),
            "right_up": pygame.image.load(IMAGE_PATH + "fish_right_up.png")
        }

        # C√°c thu·ªôc t√≠nh ban ƒë·∫ßu
        base_size = SCREEN_WIDTH // 25  # T√≠nh to√°n k√≠ch th∆∞·ªõc c∆° b·∫£n cho c√°

    # Resize t·∫•t c·∫£ 8 h∆∞·ªõng trong t·ª´ ƒëi·ªÉn self.images
        for direction in self.images:
            self.images[direction] = pygame.transform.scale(self.images[direction], (base_size, base_size))
        self.image = self.images["right"]  # H√¨nh ·∫£nh ban ƒë·∫ßu (ph·∫£i)
        self.x, self.y = x, y
        self.width, self.height = self.image.get_size()
        self.speed = PLAYER_SPEED
        self.score = 0
        self.size = 1
        self.size_old = 1
        self.eat_count = 0
        self.level = 7
        self.eat_sound = pygame.mixer.Sound(SOUND_PATH + "eat.wav")
        self.rect = self.image.get_rect(topleft=(self.x, self.y))
        self.can_dash = True
        self.dash_cooldown = 1.5
        self.is_frenzy = False
        self.dash_start_time = 0
    def check_collision(self, enemies):
        player_mask = pygame.mask.from_surface(self.image)

        for enemy in enemies[:]:
            enemy_mask = pygame.mask.from_surface(enemy.image)
            enemy_offset = (enemy.x - self.x, enemy.y - self.y)

            if player_mask.overlap(enemy_mask, enemy_offset):
                if self.level >= enemy.size:
                    self.eat_fish(enemy)
                    self.score += enemy.score_enemy
                    enemies.remove(enemy)
                elif self.level < enemy.size:
                    print(f" B·∫°n va ch·∫°m v·ªõi c√° l·ªõn h∆°n! Player Level: {self.level} - Enemy Level: {enemy.size}")
                    self.game_over()
                else:
                    print(f" C√° c√πng c·∫•p, kh√¥ng th·ªÉ ƒÉn!")

    def grow(self, enemy_level):
        """L√†m c√° ch√≠nh to l√™n khi ƒÉn c√° nh·ªè h∆°n"""
        self.size += 0.1 * (1 + enemy_level * 0.1)  # TƒÉng k√≠ch th∆∞·ªõc nhanh h∆°n khi ƒÉn c√° l·ªõn
        if self.size >= self.size_old + 1:
            self.size_old = int(self.size) + self.size * 0.1  # Ng∆∞·ª°ng l√™n c·∫•p tƒÉng d·∫ßn
            self.level += 1
            pygame.mixer.Sound.play(sound_level_up)

        # T√≠nh to√°n k√≠ch th∆∞·ªõc m·ªõi
        base_size = SCREEN_WIDTH // 25
        new_size = int(base_size * (1 + self.size * 0.07))  # T·ªâ l·ªá k√≠ch th∆∞·ªõc tƒÉng theo level
        max_size = SCREEN_WIDTH // 3  # Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc t·ªëi ƒëa
        new_size = min(new_size, max_size)

        # Resize t·∫•t c·∫£ h√¨nh ·∫£nh theo k√≠ch th∆∞·ªõc m·ªõi
        for direction in self.images:
            self.images[direction] = pygame.transform.scale(
                pygame.image.load(IMAGE_PATH + f"fish_{direction}.png"), (new_size, new_size)
            )

        self.width, self.height = new_size, new_size
        global enemy_fishes
        enemy_fishes = []

    def move1(self, keys):
        """Di chuy·ªÉn c√° ch√≠nh b·∫±ng ph√≠m m≈©i t√™n v·ªõi h·ªó tr·ª£ 8 h∆∞·ªõng"""
        current_direction = None  # M·∫∑c ƒë·ªãnh kh√¥ng c√≥ h∆∞·ªõng
        diagonal_speed = self.speed / math.sqrt(2)
        if keys[pygame.K_LEFT] and self.x > 0:
            if keys[pygame.K_UP] and self.y > 0:
                self.x -= diagonal_speed
                self.y -= diagonal_speed
                current_direction = "left_up"
            elif keys[pygame.K_DOWN] and self.y < SCREEN_HEIGHT - self.height:
                self.x -= diagonal_speed
                self.y += diagonal_speed
                current_direction = "left_down"
            else:
                self.x -= self.speed
                current_direction = "left"
        
        elif keys[pygame.K_RIGHT] and self.x < SCREEN_WIDTH - self.width:
            if keys[pygame.K_UP] and self.y > 0:
                self.x += diagonal_speed
                self.y -= diagonal_speed
                current_direction = "right_up"
            elif keys[pygame.K_DOWN] and self.y < SCREEN_HEIGHT - self.height:
                self.x += diagonal_speed
                self.y += diagonal_speed
                current_direction = "right_down"
            else:
                self.x += self.speed
                current_direction = "right"
        
        elif keys[pygame.K_UP] and self.y > 0:
            self.y -= self.speed
            current_direction = "up"
        
        elif keys[pygame.K_DOWN] and self.y < SCREEN_HEIGHT - self.height:
            self.y += self.speed
            current_direction = "down"

        # C·∫≠p nh·∫≠t h√¨nh ·∫£nh c√° theo h∆∞·ªõng di chuy·ªÉn
        if current_direction:
            self.image = self.images[current_direction]

        # C·∫≠p nh·∫≠t v·ªã tr√≠ h√¨nh ch·ªØ nh·∫≠t ƒë·∫°i di·ªán c√°
        self.rect.topleft = (self.x, self.y)

    def move(self, dx, dy):
        """Di chuy·ªÉn c√° ch√≠nh b·∫±ng AI ho·∫∑c ph√≠m"""
        if dx < 0 and dy < 0:
            current_direction = "left_up"
        elif dx > 0 and dy < 0:
            current_direction = "right_up"
        elif dx < 0 and dy > 0:
            current_direction = "left_down"
        elif dx > 0 and dy > 0:
            current_direction = "right_down"
        elif dx < 0:
            current_direction = "left"
        elif dx > 0:
            current_direction = "right"
        elif dy < 0:
            current_direction = "up"
        else:  # dy > 0
            current_direction = "down"

        self.image = self.images[current_direction]
        self.x += dx
        self.y += dy

        # Gi·ªõi h·∫°n ph·∫°m vi di chuy·ªÉn trong m√†n h√¨nh
        self.x = max(0, min(SCREEN_WIDTH - self.width, self.x))
        self.y = max(0, min(SCREEN_HEIGHT - self.height, self.y))

        self.rect.topleft = (self.x, self.y)

    def draw(self, screen):
        screen.blit(self.image, (self.x, self.y))

    def game_over(self):
        pygame.mixer.Sound.play(sound_death)
        pygame.time.delay(600)
        pygame.mixer.Sound.play(sound_game_over2)
        print("üíÄ Game Over! B·∫°n ƒë√£ b·ªã ƒÉn!")
        pygame.time.delay(3000)
        pygame.quit()
        sys.exit()

    def get_bombed(self):
        pygame.mixer.Sound.play(sound_boom)
        pygame.time.delay(600)
        pygame.mixer.Sound.play(sound_game_over2)
        print("üíÄ Game Over! B·∫°n ƒë√£ b·ªã bom n·ªï ch·∫øt!")
        pygame.time.delay(3000)
        pygame.quit()
        sys.exit()

    def restart_game(self):
        """Reset c√° ch√≠nh v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu"""
        self.x, self.y = SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2
        self.level = 0
        self.size = 1
        self.eat_count = 0

        base_size = SCREEN_WIDTH // 25
        self.image = self.images["right"]
        self.width, self.height = base_size, base_size

    def eat_fish(self, enemy):
        """X·ª≠ l√Ω khi c√° ch√≠nh ƒÉn c√° nh·ªè h∆°n"""
        self.eat_sound.play()
        self.grow(enemy.fish_level)
        print(f"üçΩÔ∏è ƒê√£ ƒÉn c√°! Player Level: {self.level} - Enemy Level: {enemy.fish_level}")

    def dash(self):
        if not self.is_frenzy:
            if self.can_dash:
                self.speed *= 2  # TƒÉng t·ªëc ƒë·ªô
                self.can_dash = False  # NgƒÉn dash ti·∫øp
                self.dash_start_time = time.time()  # Ghi th·ªùi gian b·∫Øt ƒë·∫ßu dash

    def end_dash(self):
        if self.dash_start_time and time.time() - self.dash_start_time >= 0.2:  # Dash k√©o d√†i 0.05 gi√¢y
            self.speed /= 2  # Kh√¥i ph·ª•c t·ªëc ƒë·ªô ban ƒë·∫ßu
            self.dash_start_time = None  # X√≥a tr·∫°ng th√°i dash
            self.start_cooldown()  # B·∫Øt ƒë·∫ßu cooldown

    def start_cooldown(self):
        if not self.is_frenzy:
            if not self.dash_cooldown:  # N·∫øu ch∆∞a b·∫Øt ƒë·∫ßu cooldown
                self.dash_cooldown = time.time()  # Ghi th·ªùi gian b·∫Øt ƒë·∫ßu cooldown
            elif time.time() - self.dash_cooldown >= 1.5:  # Cooldown k√©o d√†i 1.5 gi√¢y
                self.can_dash = True  # Cho ph√©p dash l·∫°i
                self.dash_cooldown = None  # K·∫øt th√∫c cooldown